import { co, z, Group } from "jazz-tools";

// ============================================================================
// PRIVATE USER DATA (Owned by User's Personal Group)
// ============================================================================

/**
 * Intention - A user's goal or practice they're working with Innio to achieve
 * Can have multiple conversations across different stages
 */
export const Intention = co.map({
  title: z.string(),
  description: z.string().optional(),
  status: z.enum(["todo", "active", "completed", "archived"]),
  createdAt: z.number(), // Unix timestamp
  updatedAt: z.number(), // Unix timestamp
  timerDuration: z.number().optional(), // Minutes, if user sets a timer
  notes: z.string().optional(), // User's personal notes
});

export type Intention = co.loaded<typeof Intention>;

/**
 * ConversationMessage - Individual message in a conversation
 */
export const ConversationMessage = co.map({
  role: z.enum(["user", "agent"]),
  content: z.string(),
  timestamp: z.number(), // Unix timestamp
});

export type ConversationMessage = co.loaded<typeof ConversationMessage>;

/**
 * Conversation - A voice interaction with Innio via ElevenLabs
 * Structure based on ElevenLabs conversation API response
 */
export const Conversation = co.map({
  // ElevenLabs conversation metadata
  elevenLabsId: z.string(), // conversation_id from ElevenLabs
  agentId: z.string(),
  startTime: z.number(), // Unix timestamp
  endTime: z.number().optional(), // Unix timestamp
  callSuccessful: z.boolean().optional(),
  summary: z.string().optional(), // AI-generated summary from ElevenLabs

  // Pond-specific data
  intentionRef: co.optional(Intention), // Reference to associated intention (if any)
  messages: co.list(ConversationMessage), // Transcript
  userReflection: z.string().optional(), // User's post-conversation notes

  // Metadata
  createdAt: z.number(), // Unix timestamp
});

export type Conversation = co.loaded<typeof Conversation>;

/**
 * FieldNote - Innio's private observations about the user
 * Generated by AI after conversations, stored privately for personalization
 */
export const FieldNote = co.map({
  content: z.string(), // Innio's reflection/observation
  conversationRef: co.optional(Conversation), // Optional link to conversation that inspired it
  createdAt: z.number(), // Unix timestamp
  tags: co.list(z.string()), // Categories: e.g., ["insight", "pattern", "question"]
});

export type FieldNote = co.loaded<typeof FieldNote>;



/**
 * PondAccountRoot - Private root for each user
 * All data here is private by default (owned by user's personal group)
 */
export const PondAccountRoot = co.map({
  // Core data collections
  intentions: co.list(Intention),
  conversations: co.list(Conversation),
  fieldNotes: co.list(FieldNote), // Innio's private notes about this user

  // AI-generated state (stored as JSON strings, updated atomically)
  worldModel: co.plainText(), // JSON: user's inferred values, beliefs, fears, memories, relationships


});

export type PondAccountRoot = co.loaded<typeof PondAccountRoot>;

/**
 * PondProfile - Public profile schema using Jazz's co.profile()
 */
export const PondProfile = co.profile({
  name: z.string(),
});

export type PondProfile = co.loaded<typeof PondProfile>;

/**
 * PondAccount - Main account schema
 * Per Jazz patterns, includes migration for initialization
 */
export const PondAccount = co
  .account({
    root: PondAccountRoot,
    profile: PondProfile,
  })
  .withMigration((account, creationProps?: { name?: string }) => {
    if (account.root === undefined) {
      (account as any).root = PondAccountRoot.create({
        intentions: co.list(Intention).create([]),
        conversations: co.list(Conversation).create([]),
        fieldNotes: co.list(FieldNote).create([]),
        worldModel: co.plainText().create(
          JSON.stringify({
            version: 1,
            created: Date.now(),
            values: [],
            personality: {},
            fears: [],
            beliefs: [],
            memories: [],
            relationships: [],
          })
        )
      });
    }

    if (account.profile === undefined) {
      const profileGroup = Group.create();
      profileGroup.makePublic();

      (account as any).profile = PondProfile.create(
        {
          name: creationProps?.name || "New User",
        },
        profileGroup
      );
    }
  });

export type PondAccount = co.loaded<typeof PondAccount>;

